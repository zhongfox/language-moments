# 8.5 导出与可见性

### 1. Ruby

* 源文件被require后, 其中的局部变量是源文件外不可见的, 其他(常量, 全局变量)是可见的.

* (面向对象)类有可见性控制
  * `public`
  * `protected` 可以继承，只能在类内部访问，可以指定接收对象
  * `private` 可以继承，只能在类内部访问，不能指定接收对象（只能隐式使用self）

---

### 2. Node.js

Node利用包装函数进行模块加载, 包装函数的其中2个形参是`exports` `module`. exports 是导出内容, module代表当前模块, exports是module的属性.

因为包装函数的存在, 模块中原来的顶层变量变成了包装函数中的局部变量, 在模块外不可见, 这样有效地实现了命名空间的隔离.

在引入模块中, 创建一个和被引入模块名称一样的局部变量, 是一种惯例, 如 `var http = require("http");`

不要直接给exports赋值, 因为exports是一个形参, **直接赋值形参会改变形参的引用,但是不能改变作用域外的值**, 迂回方案是给`module.exports`直接赋值.

---

### 3. Go

* 所有成员本包内可见, 无论是否在同一源文件

* 首字母大写成员包外可见(导出成员)

  适用于包内全局变量, 全局常量, 类型, 结构字段, 函数, 方法等

* 内部包(在internal目录下的包): 仅可以被该包父目录下的包访问

* 嵌入类型的字段或者属性, 不受嵌入类型本身可见性影响:

  ```go
  type Admin struct {
    user             // 嵌入不可见类型
  }

  type user struct { // 不可见
    Name string      // 可见的属性
  }

  a := Admin{"zhongfox"}
  a.Name             // 在包外可以访问
  ```

---

### 4. Lua

* 源文件(模块)被require后, 其中的局部变量是源文件外不可见的, 全局变量是模块外可见.

* 源文件(模块)被require后, 可以通过return 导出.<!-- 因为包裹function的原因, 导出的变量受闭包控制 -->


<!--
### Java

* public: 对所有类可见
* protected: 对同一包内的类和所有包内外子类可见 (2个条件是或关系, 满足一个就行)
* 默认/default: 在同一包内可见
* private: 在同一类内可见
-->

